/* tslint:disable */
/* eslint-disable */
/**
 * Green Route API
 * This API provides access to the Green Route service.
 *
 * The version of the OpenAPI document: latest
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface AuthenticationPayload
 */
export interface AuthenticationPayload {
  /**
   *
   * @type {string}
   * @memberof AuthenticationPayload
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof AuthenticationPayload
   */
  provider_id?: string;
}
/**
 *
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Exception
 */
export interface Exception {
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Forecast
 */
export interface Forecast {
  /**
   *
   * @type {ForecastLocation}
   * @memberof Forecast
   */
  location?: ForecastLocation;
  /**
   *
   * @type {Array<ForecastDay>}
   * @memberof Forecast
   */
  forecast?: Array<ForecastDay>;
}
/**
 *
 * @export
 * @interface ForecastDay
 */
export interface ForecastDay {
  /**
   *
   * @type {string}
   * @memberof ForecastDay
   */
  date?: string;
  /**
   *
   * @type {ForecastDayDay}
   * @memberof ForecastDay
   */
  day?: ForecastDayDay;
}
/**
 *
 * @export
 * @interface ForecastDayDay
 */
export interface ForecastDayDay {
  /**
   * Temperature in Celsius multiply by 100
   * @type {number}
   * @memberof ForecastDayDay
   */
  max_temp?: number;
  /**
   * Temperature in Celsius multiply by 100
   * @type {number}
   * @memberof ForecastDayDay
   */
  min_temp?: number;
  /**
   *
   * @type {ForecastDayDayCondition}
   * @memberof ForecastDayDay
   */
  condition?: ForecastDayDayCondition;
}
/**
 *
 * @export
 * @interface ForecastDayDayCondition
 */
export interface ForecastDayDayCondition {
  /**
   *
   * @type {string}
   * @memberof ForecastDayDayCondition
   */
  text?: string;
  /**
   * icon link
   * @type {string}
   * @memberof ForecastDayDayCondition
   */
  icon?: string;
}
/**
 *
 * @export
 * @interface ForecastLocation
 */
export interface ForecastLocation {
  /**
   *
   * @type {string}
   * @memberof ForecastLocation
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ForecastLocation
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof ForecastLocation
   */
  country?: string;
}
/**
 *
 * @export
 * @interface Fuel
 */
export interface Fuel {
  /**
   *
   * @type {string}
   * @memberof Fuel
   */
  type?: FuelTypeEnum;
}

export const FuelTypeEnum = {
  BioDiesel: 'BIO_DIESEL',
  Diesel: 'DIESEL',
  Ethanol: 'ETHANOL',
  Gasoline: 'GASOLINE',
  Electricity: 'ELECTRICITY',
  NaturalGas: 'NATURAL_GAS',
  BioBas: 'BIO_BAS',
  FossilGas: 'FOSSIL_GAS'
} as const;

export type FuelTypeEnum = (typeof FuelTypeEnum)[keyof typeof FuelTypeEnum];

/**
 *
 * @export
 * @interface GetForecastRequest
 */
export interface GetForecastRequest {
  /**
   *
   * @type {string}
   * @memberof GetForecastRequest
   */
  origin?: string;
  /**
   *
   * @type {string}
   * @memberof GetForecastRequest
   */
  destination?: string;
}
/**
 *
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Itinerary
 */
export interface Itinerary {
  /**
   *
   * @type {string}
   * @memberof Itinerary
   */
  title?: string;
  /**
   *
   * @type {ItineraryTransport}
   * @memberof Itinerary
   */
  transport?: ItineraryTransport;
  /**
   *
   * @type {ItineraryTransport}
   * @memberof Itinerary
   */
  accommodation?: ItineraryTransport;
  /**
   *
   * @type {string}
   * @memberof Itinerary
   */
  travel_description?: string;
}
/**
 *
 * @export
 * @interface ItineraryTransport
 */
export interface ItineraryTransport {
  /**
   * Carbone footprint
   * @type {number}
   * @memberof ItineraryTransport
   */
  co2e?: number;
  /**
   * Carbone footprint per person
   * @type {number}
   * @memberof ItineraryTransport
   */
  co2e_pp?: number;
}
/**
 *
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface TravelDescription
 */
export interface TravelDescription {
  /**
   *
   * @type {string}
   * @memberof TravelDescription
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof TravelDescription
   */
  to?: string;
  /**
   *
   * @type {number}
   * @memberof TravelDescription
   */
  distance?: number;
  /**
   * How many persons are going to travel?
   * @type {number}
   * @memberof TravelDescription
   */
  people?: number;
  /**
   *
   * @type {string}
   * @memberof TravelDescription
   */
  accommodation_type?: TravelDescriptionAccommodationTypeEnum;
  /**
   * Number of nights, defaults to 1.
   * @type {number}
   * @memberof TravelDescription
   */
  nights?: number;
  /**
   *
   * @type {Vehicle}
   * @memberof TravelDescription
   */
  vehicle?: Vehicle;
}

export const TravelDescriptionAccommodationTypeEnum = {
  Hotel: 'HOTEL',
  Hostel: 'HOSTEL',
  Tent: 'TENT',
  Apartment: 'APARTMENT',
  Room: 'ROOM',
  RentedApartment: 'RENTED_APARTMENT'
} as const;

export type TravelDescriptionAccommodationTypeEnum = (typeof TravelDescriptionAccommodationTypeEnum)[keyof typeof TravelDescriptionAccommodationTypeEnum];

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  last_name?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  authentication_id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  first_name?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  birth_date?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  photo_id?: string;
}
/**
 *
 * @export
 * @interface Vehicle
 */
export interface Vehicle {
  /**
   *
   * @type {string}
   * @memberof Vehicle
   */
  type?: VehicleTypeEnum;
  /**
   *
   * @type {Fuel}
   * @memberof Vehicle
   */
  fuel?: Fuel;
}

export const VehicleTypeEnum = {
  Bicycle: 'BICYCLE',
  SmallCar: 'SMALL_CAR',
  LargeCar: 'LARGE_CAR',
  Bus: 'BUS',
  Minivan: 'MINIVAN',
  MotorHome: 'MOTOR_HOME',
  FlightRegularEconomy: 'FLIGHT_REGULAR_ECONOMY',
  FlightCharterEconomy: 'FLIGHT_CHARTER_ECONOMY',
  Hiking: 'HIKING',
  Kayak: 'KAYAK',
  Tram: 'TRAM',
  Subway: 'SUBWAY',
  Ferry: 'FERRY',
  Train: 'TRAIN',
  Walking: 'WALKING'
} as const;

export type VehicleTypeEnum = (typeof VehicleTypeEnum)[keyof typeof VehicleTypeEnum];

/**
 *
 * @export
 * @interface Weather
 */
export interface Weather {
  /**
   *
   * @type {Forecast}
   * @memberof Weather
   */
  origin?: Forecast;
  /**
   *
   * @type {Forecast}
   * @memberof Weather
   */
  destination?: Forecast;
}

/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve file
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('downloadFile', 'fileId', fileId);
      const localVarPath = `/raw/{fileId}`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Upload standard file
     * @param {string} fileId
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (fileId: string, body?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('uploadFile', 'fileId', fileId);
      const localVarPath = `/raw/{fileId}`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'image/*';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve file
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(fileId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FileApi.downloadFile']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Upload standard file
     * @param {string} fileId
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(fileId: string, body?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(fileId, body, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FileApi.uploadFile']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    }
  };
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FileApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve file
     * @param {FileApiDownloadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(requestParameters: FileApiDownloadFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
      return localVarFp.downloadFile(requestParameters.fileId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload standard file
     * @param {FileApiUploadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(requestParameters: FileApiUploadFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.uploadFile(requestParameters.fileId, requestParameters.body, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * Request parameters for downloadFile operation in FileApi.
 * @export
 * @interface FileApiDownloadFileRequest
 */
export interface FileApiDownloadFileRequest {
  /**
   *
   * @type {string}
   * @memberof FileApiDownloadFile
   */
  readonly fileId: string;
}

/**
 * Request parameters for uploadFile operation in FileApi.
 * @export
 * @interface FileApiUploadFileRequest
 */
export interface FileApiUploadFileRequest {
  /**
   *
   * @type {string}
   * @memberof FileApiUploadFile
   */
  readonly fileId: string;

  /**
   *
   * @type {File}
   * @memberof FileApiUploadFile
   */
  readonly body?: File;
}

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
  /**
   *
   * @summary Retrieve file
   * @param {FileApiDownloadFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileApi
   */
  public downloadFile(requestParameters: FileApiDownloadFileRequest, options?: RawAxiosRequestConfig) {
    return FileApiFp(this.configuration)
      .downloadFile(requestParameters.fileId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload standard file
   * @param {FileApiUploadFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileApi
   */
  public uploadFile(requestParameters: FileApiUploadFileRequest, options?: RawAxiosRequestConfig) {
    return FileApiFp(this.configuration)
      .uploadFile(requestParameters.fileId, requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Check server health
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     * Check server health
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HealthApi.ping']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    }
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     * Check server health
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.ping(options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * Check server health
   * @summary Health check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .ping(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RouteApi - axios parameter creator
 * @export
 */
export const RouteApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Eco-friendly itineraries according to travel description
     * @param {TravelDescription} travelDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateItineraries: async (travelDescription: TravelDescription, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'travelDescription' is not null or undefined
      assertParamExists('generateItineraries', 'travelDescription', travelDescription);
      const localVarPath = `/itineraries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(travelDescription, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get next 3 days forecast
     * @param {GetForecastRequest} [getForecastRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecast: async (getForecastRequest?: GetForecastRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/weathers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(getForecastRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * RouteApi - functional programming interface
 * @export
 */
export const RouteApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RouteApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Eco-friendly itineraries according to travel description
     * @param {TravelDescription} travelDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateItineraries(
      travelDescription: TravelDescription,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Itinerary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateItineraries(travelDescription, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RouteApi.generateItineraries']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get next 3 days forecast
     * @param {GetForecastRequest} [getForecastRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getForecast(getForecastRequest?: GetForecastRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Weather>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getForecast(getForecastRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RouteApi.getForecast']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    }
  };
};

/**
 * RouteApi - factory interface
 * @export
 */
export const RouteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = RouteApiFp(configuration);
  return {
    /**
     *
     * @summary Eco-friendly itineraries according to travel description
     * @param {RouteApiGenerateItinerariesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateItineraries(requestParameters: RouteApiGenerateItinerariesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Itinerary> {
      return localVarFp.generateItineraries(requestParameters.travelDescription, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get next 3 days forecast
     * @param {RouteApiGetForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getForecast(requestParameters: RouteApiGetForecastRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Weather> {
      return localVarFp.getForecast(requestParameters.getForecastRequest, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * Request parameters for generateItineraries operation in RouteApi.
 * @export
 * @interface RouteApiGenerateItinerariesRequest
 */
export interface RouteApiGenerateItinerariesRequest {
  /**
   *
   * @type {TravelDescription}
   * @memberof RouteApiGenerateItineraries
   */
  readonly travelDescription: TravelDescription;
}

/**
 * Request parameters for getForecast operation in RouteApi.
 * @export
 * @interface RouteApiGetForecastRequest
 */
export interface RouteApiGetForecastRequest {
  /**
   *
   * @type {GetForecastRequest}
   * @memberof RouteApiGetForecast
   */
  readonly getForecastRequest?: GetForecastRequest;
}

/**
 * RouteApi - object-oriented interface
 * @export
 * @class RouteApi
 * @extends {BaseAPI}
 */
export class RouteApi extends BaseAPI {
  /**
   *
   * @summary Eco-friendly itineraries according to travel description
   * @param {RouteApiGenerateItinerariesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouteApi
   */
  public generateItineraries(requestParameters: RouteApiGenerateItinerariesRequest, options?: RawAxiosRequestConfig) {
    return RouteApiFp(this.configuration)
      .generateItineraries(requestParameters.travelDescription, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get next 3 days forecast
   * @param {RouteApiGetForecastRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouteApi
   */
  public getForecast(requestParameters: RouteApiGetForecastRequest = {}, options?: RawAxiosRequestConfig) {
    return RouteApiFp(this.configuration)
      .getForecast(requestParameters.getForecastRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Login user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/signin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Sign up user
     * @param {User} user Sign up payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'user' is not null or undefined
      assertParamExists('signUp', 'user', user);
      const localVarPath = `/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Login user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signIn(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SecurityApi.signIn']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Sign up user
     * @param {User} user Sign up payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signUp(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(user, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SecurityApi.signUp']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    }
  };
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SecurityApiFp(configuration);
  return {
    /**
     *
     * @summary Login user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn(options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp.signIn(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Sign up user
     * @param {SecurityApiSignUpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp(requestParameters: SecurityApiSignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp.signUp(requestParameters.user, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * Request parameters for signUp operation in SecurityApi.
 * @export
 * @interface SecurityApiSignUpRequest
 */
export interface SecurityApiSignUpRequest {
  /**
   * Sign up payload.
   * @type {User}
   * @memberof SecurityApiSignUp
   */
  readonly user: User;
}

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary Login user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signIn(options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signIn(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Sign up user
   * @param {SecurityApiSignUpRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signUp(requestParameters: SecurityApiSignUpRequest, options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signUp(requestParameters.user, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get user activities history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/activities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get user by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUserById', 'id', id);
      const localVarPath = `/users/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Update user photo
     * @param {string} id
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfilePic: async (id: string, body?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateProfilePic', 'id', id);
      const localVarPath = `/users/{id}/raw`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'image/*';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get user activities history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Itinerary>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.getActivities']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get user by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.getUserById']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Update user photo
     * @param {string} id
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProfilePic(id: string, body?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfilePic(id, body, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.updateProfilePic']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    }
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @summary Get user activities history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities(options?: RawAxiosRequestConfig): AxiosPromise<Array<Itinerary>> {
      return localVarFp.getActivities(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user by identifier
     * @param {UserApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(requestParameters: UserApiGetUserByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp.getUserById(requestParameters.id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update user photo
     * @param {UserApiUpdateProfilePicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfilePic(requestParameters: UserApiUpdateProfilePicRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.updateProfilePic(requestParameters.id, requestParameters.body, options).then((request) => request(axios, basePath));
    }
  };
};

/**
 * Request parameters for getUserById operation in UserApi.
 * @export
 * @interface UserApiGetUserByIdRequest
 */
export interface UserApiGetUserByIdRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiGetUserById
   */
  readonly id: string;
}

/**
 * Request parameters for updateProfilePic operation in UserApi.
 * @export
 * @interface UserApiUpdateProfilePicRequest
 */
export interface UserApiUpdateProfilePicRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiUpdateProfilePic
   */
  readonly id: string;

  /**
   *
   * @type {File}
   * @memberof UserApiUpdateProfilePic
   */
  readonly body?: File;
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Get user activities history
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getActivities(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getActivities(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user by identifier
   * @param {UserApiGetUserByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserById(requestParameters: UserApiGetUserByIdRequest, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUserById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update user photo
   * @param {UserApiUpdateProfilePicRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateProfilePic(requestParameters: UserApiUpdateProfilePicRequest, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .updateProfilePic(requestParameters.id, requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
